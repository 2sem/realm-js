{"version":3,"file":"Configuration.js","sourceRoot":"","sources":["Configuration.ts"],"names":[],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2022 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nimport {\n  DefaultObject,\n  ObjectSchema,\n  Realm,\n  RealmObject,\n  RealmObjectConstructor,\n  SyncConfiguration,\n  assert,\n  ClientResetConfig,\n  ClientResetMode,\n  ErrorCallback,\n} from \"./internal\";\n\n// export type Configuration = ConfigurationWithSync | ConfigurationWithoutSync;\nexport type Configuration = BaseConfiguration;\n/**\n * A function which can be called to migrate a Realm from one version of the schema to another.\n */\nexport type MigrationCallback = (oldRealm: Realm, newRealm: Realm) => void;\n\ntype BaseConfiguration = {\n  path?: string;\n  schema?: (RealmObjectConstructor<any> | ObjectSchema)[];\n  schemaVersion?: number;\n  inMemory?: boolean;\n  readOnly?: boolean;\n  fifoFilesFallbackPath?: string;\n  sync?: SyncConfiguration;\n  shouldCompact?: (totalBytes: number, usedBytes: number) => boolean;\n  deleteRealmIfMigrationNeeded?: boolean;\n  disableFormatUpgrade?: boolean;\n  encryptionKey?: ArrayBuffer | ArrayBufferView | Int8Array;\n  onMigration?: MigrationCallback;\n};\n\n// type ConfigurationWithSync = BaseConfiguration & {\n//   sync: Record<string, unknown>;\n// };\n\n// type ConfigurationWithoutSync = BaseConfiguration & {\n//   sync?: never;\n// };\n\n// export type PartitionValue = string | number | null | ObjectId | UUID;\n\n// /**\n//  * A function which can be called to migrate a Realm from one version of the schema to another.\n//  */\n// export type MigrationCallback = (oldRealm: Realm, newRealm: Realm) => void;\n\n// export type SSLVerifyObject = {\n//   serverAddress: string;\n//   serverPort: number;\n//   pemCertificate: string;\n//   acceptedByOpenSSL: boolean;\n//   depth: number;\n// };\n\n// export type SSLVerifyCallback = (sslVerifyObject: SSLVerifyObject) => boolean;\n// export type SSLConfiguration = {\n//   validate?: boolean;\n//   certificatePath?: string;\n//   validateCallback?: SSLVerifyCallback;\n// };\n\n// export enum ClientResetModeManualOnly {\n//   Manual = \"manual\",\n// }\n\n// export enum ClientResetMode {\n//   Manual = \"manual\",\n//   DiscardLocal = \"discardLocal\",\n// }\n\n// export type ClientResetBeforeCallback = (localRealm: Realm) => void;\n// export type ClientResetAfterCallback = (localRealm: Realm, remoteRealm: Realm) => void;\n// export type ClientResetConfiguration<ClientResetModeT = ClientResetMode> = {\n//   mode: ClientResetModeT;\n//   clientResetBefore?: ClientResetBeforeCallback;\n//   clientResetAfter?: ClientResetAfterCallback;\n// };\n\n// export type BaseSyncConfiguration = {\n//   user: User;\n//   customHttpHeaders?: { [header: string]: string };\n//   ssl?: SSLConfiguration;\n//   _sessionStopPolicy?: SessionStopPolicy;\n//   newRealmFileBehavior?: OpenRealmBehaviorConfiguration;\n//   existingRealmFileBehavior?: OpenRealmBehaviorConfiguration;\n//   error?: ErrorCallback;\n// };\n\n// // We only allow `flexible` to be `true` or `undefined` - `{ flexible: false }`\n// // is not allowed. This is because TypeScript cannot discriminate that\n// // type correctly with `strictNullChecks` disabled, and there's no real use\n// // case for `{ flexible: false }`.\n// export type FlexibleSyncConfiguration = BaseSyncConfiguration & {\n//   flexible: true;\n//   partitionValue?: never;\n//   clientReset?: ClientResetConfiguration<ClientResetModeManualOnly>;\n//   /**\n//    * Optional object to configure the setup of an initial set of flexible\n//    * sync subscriptions to be used when opening the Realm. If this is specified,\n//    * {@link Realm.open} will not resolve until this set of subscriptions has been\n//    * fully synchronized with the server.\n//    *\n//    * Example:\n//    * ```\n//    * const config: Realm.Configuration = {\n//    *   sync: {\n//    *     user,\n//    *     flexible: true,\n//    *     initialSubscriptions: {\n//    *       update: (subs, realm) => {\n//    *         subs.add(realm.objects('Task'));\n//    *       },\n//    *       rerunOnOpen: true,\n//    *     },\n//    *   },\n//    *   // ... rest of config ...\n//    * };\n//    * const realm = await Realm.open(config);\n//    *\n//    * // At this point, the Realm will be open with the data for the initial set\n//    * // subscriptions fully synchronised.\n//    * ```\n//    */\n//   initialSubscriptions?: {\n//     /**\n//      * Callback called with the {@link Realm} instance to allow you to setup the\n//      * initial set of subscriptions by calling `realm.subscriptions.update`.\n//      * See {@link Realm.App.Sync.SubscriptionSet.update} for more information.\n//      */\n//     update: (subs: Realm.App.Sync.MutableSubscriptionSet, realm: Realm) => void;\n//     /**\n//      * If `true`, the {@link update} callback will be rerun every time the Realm is\n//      * opened (e.g. every time a user opens your app), otherwise (by default) it\n//      * will only be run if the Realm does not yet exist.\n//      */\n//     rerunOnOpen?: boolean;\n//   };\n// };\n\n// export type PartitionSyncConfiguration = BaseSyncConfiguration & {\n//   flexible?: never;\n//   partitionValue: PartitionValue;\n//   clientReset?: ClientResetConfiguration<ClientResetMode>;\n// };\n\n// export type SyncConfiguration = FlexibleSyncConfiguration | PartitionSyncConfiguration;\n\n// export type BaseConfiguration = {\n//   encryptionKey?: ArrayBuffer | ArrayBufferView | Int8Array;\n//   schema?: (ObjectConstructor | ObjectSchema)[];\n//   schemaVersion?: number;\n//   shouldCompactOnLaunch?: (totalBytes: number, usedBytes: number) => boolean;\n//   onFirstOpen?: (realm: Realm) => void;\n//   path?: string;\n//   fifoFilesFallbackPath?: string;\n//   readOnly?: boolean;\n// };\n\n// export type ConfigurationWithSync = BaseConfiguration & {\n//   sync: SyncConfiguration;\n//   migration?: never;\n//   inMemory?: never;\n//   deleteRealmIfMigrationNeeded?: never;\n//   disableFormatUpgrade?: never;\n// };\n\n// export type ConfigurationWithoutSync = BaseConfiguration & {\n//   sync?: never;\n//   migration?: MigrationCallback;\n//   inMemory?: boolean;\n//   deleteRealmIfMigrationNeeded?: boolean;\n//   disableFormatUpgrade?: boolean;\n// };\n\nexport function validateConfiguration(arg: unknown): asserts arg is Configuration {\n  assert.object(arg);\n  const { path, schema, onMigration, sync } = arg;\n  if (typeof onMigration !== \"undefined\") {\n    assert.function(onMigration, \"migration\");\n  }\n  if (typeof path === \"string\") {\n    assert(path.length > 0, \"Expected a non-empty path or none at all\");\n  }\n  if (onMigration && sync) {\n    throw new Error(\"Options 'onMigration' and 'sync' are mutually exclusive\");\n  }\n  if (schema) {\n    validateRealmSchema(schema);\n  }\n}\n\nexport function validateRealmSchema(schema: unknown): asserts schema is Configuration[\"schema\"][] {\n  assert.array(schema, \"schema\");\n  schema.forEach(validateObjectSchema);\n  // TODO: Assert that backlinks point to object schemas that are actually declared\n}\n\nexport function validateObjectSchema(arg: unknown): asserts arg is ObjectSchema {\n  if (typeof arg === \"function\") {\n    // Class based model\n    const clazz = arg as unknown as DefaultObject;\n    // We assert this later, but want a custom error message\n    if (!(arg.prototype instanceof RealmObject)) {\n      const schemaName = clazz.schema && (clazz.schema as DefaultObject).name;\n      if (typeof schemaName === \"string\" && schemaName != arg.name) {\n        throw new TypeError(`Class '${arg.name}' (declaring '${schemaName}' schema) must extend Realm.Object`);\n      } else {\n        throw new TypeError(`Class '${arg.name}' must extend Realm.Object`);\n      }\n    }\n    assert.object(clazz.schema, \"schema static\");\n    validateObjectSchema(clazz.schema);\n  } else {\n    assert.object(arg, \"object schema\");\n    const { name, properties, asymmetric, embedded } = arg;\n    assert.string(name, \"name\");\n    assert.object(properties, \"properties\");\n    if (typeof asymmetric !== \"undefined\") {\n      assert.boolean(asymmetric);\n    }\n    if (typeof embedded !== \"undefined\") {\n      assert.boolean(embedded);\n    }\n    assert(!asymmetric || !embedded, `Cannot be both asymmetric and embedded`);\n  }\n}\n\n"]}