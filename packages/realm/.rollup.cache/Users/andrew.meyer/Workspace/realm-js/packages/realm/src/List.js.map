{"version":3,"file":"List.js","sourceRoot":"","sources":["List.ts"],"names":[],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2022 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nimport {\n  IllegalConstructorError,\n  OrderedCollection,\n  OrderedCollectionHelpers,\n  Realm,\n  assert,\n  binding,\n} from \"./internal\";\n\ntype PartiallyWriteableArray<T> = Pick<Array<T>, \"pop\" | \"push\" | \"shift\" | \"unshift\" | \"splice\">;\n\n/**\n * Instances of this class will be returned when accessing object properties whose type is `\"list\"`.\n *\n * Lists mostly behave like normal Javascript Arrays, except for that they can\n * only store values of a single type (indicated by the `type` and `optional`\n * properties of the List), and can only be modified inside a {@link Realm.write | write} transaction.\n *\n * @extends Realm.Collection\n * @memberof Realm\n */\nexport class List<T = unknown> extends OrderedCollection<T> implements PartiallyWriteableArray<T> {\n  /**\n   * The representation in the binding.\n   * @internal\n   */\n  public internal!: binding.List;\n\n  /** @internal */\n  private isEmbedded!: boolean;\n\n  /** @internal */\n  constructor(realm: Realm, internal: binding.List, helpers: OrderedCollectionHelpers) {\n    if (arguments.length === 0 || !(internal instanceof binding.List)) {\n      throw new IllegalConstructorError(\"List\");\n    }\n    super(realm, internal.asResults(), helpers);\n\n    // Getting the `objectSchema` off the internal will throw if base type isn't object\n    const baseType = this.results.type & ~binding.PropertyType.Flags;\n    const isEmbedded =\n      baseType === binding.PropertyType.Object && internal.objectSchema.tableType === binding.TableType.Embedded;\n\n    Object.defineProperties(this, {\n      internal: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: internal,\n      },\n      isEmbedded: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: isEmbedded,\n      },\n    });\n  }\n\n  isValid() {\n    return this.internal.isValid;\n  }\n\n  /**\n   * Set an element of the ordered collection by index\n   * @param index The index\n   * @param value The value\n   * @internal\n   */\n  public set(index: number, value: unknown) {\n    const {\n      realm,\n      internal,\n      isEmbedded,\n      helpers: { toBinding },\n    } = this;\n    assert.inTransaction(realm);\n    // TODO: Consider a more performant way to determine if the list is embedded\n    internal.setAny(index, toBinding(value, isEmbedded ? () => [internal.insertEmbedded(index), true] : undefined));\n  }\n\n  get length(): number {\n    return this.internal.size;\n  }\n\n  /**\n   * Remove the **last** value from the list and return it.\n   * @throws {@link AssertionError} If not inside a write transaction.\n   * @returns The last value or undefined if the list is empty.\n   */\n  pop(): T | undefined {\n    assert.inTransaction(this.realm);\n    const {\n      internal,\n      helpers: { fromBinding },\n    } = this;\n    const lastIndex = internal.size - 1;\n    if (lastIndex >= 0) {\n      const result = fromBinding(internal.getAny(lastIndex));\n      internal.remove(lastIndex);\n      return result as T;\n    }\n  }\n\n  /**\n   * Add one or more values to the _end_ of the list.\n   *\n   * @param items Values to add to the list.\n   * @throws {TypeError} If a `value` is not of a type which can be stored in\n   *   the list, or if an object being added to the list does not match the {@link Realm.ObjectSchema} for the list.\n   *\n   * @throws {@link AssertionError} If not inside a write transaction.\n   * @returns A number equal to the new length of\n   *          the list after adding the values.\n   */\n  push(...items: T[]): number {\n    assert.inTransaction(this.realm);\n    const {\n      isEmbedded,\n      internal,\n      helpers: { toBinding },\n    } = this;\n    const start = internal.size;\n    for (const [offset, item] of items.entries()) {\n      const index = start + offset;\n      if (isEmbedded) {\n        // Simply transforming to binding will insert the embedded object\n        toBinding(item, () => [internal.insertEmbedded(index), true]);\n      } else {\n        internal.insertAny(index, toBinding(item));\n      }\n    }\n    return internal.size;\n  }\n\n  /**\n   * Remove the **first** value from the list and return it.\n   * @throws {@link AssertionError} If not inside a write transaction.\n   * @returns The first value or undefined if the list is empty.\n   */\n  shift(): T | undefined {\n    assert.inTransaction(this.realm);\n    const {\n      internal,\n      helpers: { fromBinding },\n    } = this;\n    if (internal.size > 0) {\n      const result = fromBinding(internal.getAny(0)) as T;\n      internal.remove(0);\n      return result;\n    }\n  }\n\n  /**\n   * Add one or more values to the _beginning_ of the list.\n   *\n   * @param items Values to add to the list.\n   * @throws {TypeError} If a `value` is not of a type which can be stored in\n   * the list, or if an object being added to the list does not match the {@link Realm.ObjectSchema} for the list.\n   * @throws {@link AssertionError} If not inside a write transaction.\n   * @returns The new {@link length} of the list after adding the values.\n   */\n  unshift(...items: T[]): number {\n    assert.inTransaction(this.realm);\n    const {\n      isEmbedded,\n      internal,\n      helpers: { toBinding },\n    } = this;\n    for (const [index, item] of items.entries()) {\n      if (isEmbedded) {\n        // Simply transforming to binding will insert the embedded object\n        toBinding(item, () => [internal.insertEmbedded(index), true]);\n      } else {\n        internal.insertAny(index, toBinding(item));\n      }\n    }\n    return internal.size;\n  }\n\n  /** TODO\n   * Changes the contents of the list by removing value and/or inserting new value.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}\n   * @param start The start index. If greater than the length of the list,\n   *   the start index will be set to the length instead. If negative, then the start index\n   *   will be counted from the end of the list (e.g. `list.length - index`).\n   * @param deleteCount The number of values to remove from the list.\n   *   If not provided, then all values from the start index through the end of\n   *   the list will be removed.\n   * @returns An array containing the value that were removed from the list. The\n   *   array is empty if no value were removed.\n   */\n  splice(start: number, deleteCount?: number): T[];\n  /**\n   * Changes the contents of the list by removing value and/or inserting new value.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}\n   * @param start The start index. If greater than the length of the list,\n   *   the start index will be set to the length instead. If negative, then the start index\n   *   will be counted from the end of the list (e.g. `list.length - index`).\n   * @param deleteCount The number of values to remove from the list.\n   *   If not provided, then all values from the start index through the end of\n   *   the list will be removed.\n   * @param items Values to insert into the list starting at `index`.\n   * @returns An array containing the value that were removed from the list. The\n   *   array is empty if no value were removed.\n   */\n  splice(start: number, deleteCount: number, ...items: T[]): T[];\n  /**\n   * Changes the contents of the list by removing value and/or inserting new value.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}\n   * @param start The start index. If greater than the length of the list,\n   *   the start index will be set to the length instead. If negative, then the start index\n   *   will be counted from the end of the list (e.g. `list.length - index`).\n   * @param deleteCount The number of values to remove from the list.\n   *   If not provided, then all values from the start index through the end of\n   *   the list will be removed.\n   * @param items Values to insert into the list starting at `index`.\n   * @returns An array containing the value that were removed from the list. The\n   *   array is empty if no value were removed.\n   */\n  splice(start: number, deleteCount?: number, ...items: T[]): T[] {\n    // Comments in the code below is copied from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n    assert.inTransaction(this.realm);\n    assert.number(start, \"start\");\n    const {\n      isEmbedded,\n      internal,\n      helpers: { fromBinding, toBinding },\n    } = this;\n    // If negative, it will begin that many elements from the end of the array.\n    if (start < 0) {\n      start = internal.size + start;\n    }\n    // If greater than the length of the array, start will be set to the length of the array.\n    if (start > internal.size) {\n      start = internal.size;\n    }\n    // If deleteCount is omitted, or if its value is equal to or larger than array.length - start\n    // (that is, if it is equal to or greater than the number of elements left in the array, starting at start),\n    // then all the elements from start to the end of the array will be deleted.\n    const end = typeof deleteCount === \"number\" ? Math.min(start + deleteCount, internal.size) : internal.size;\n    // Get the elements that are about to be deleted\n    const result: T[] = [];\n    for (let i = start; i < end; i++) {\n      result.push(fromBinding(internal.getAny(i)) as T);\n    }\n    // Remove the elements from the list (backwards to avoid skipping elements as they're being deleted)\n    for (let i = end - 1; i >= start; i--) {\n      internal.remove(i);\n    }\n    // Insert any new elements\n    for (const [offset, item] of items.entries()) {\n      const index = start + offset;\n      if (isEmbedded) {\n        // Simply transforming to binding will insert the embedded object\n        toBinding(item, () => [internal.insertEmbedded(index), true]);\n      } else {\n        internal.insertAny(index, toBinding(item));\n      }\n    }\n    return result;\n  }\n}\n"]}