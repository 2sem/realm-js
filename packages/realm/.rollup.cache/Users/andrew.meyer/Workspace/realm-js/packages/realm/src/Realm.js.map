{"version":3,"file":"Realm.js","sourceRoot":"","sources":["Realm.ts"],"names":[],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2022 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nimport {\n  ApiKeyAuthClient,\n  App,\n  BSON,\n  CanonicalObjectSchema,\n  ClassHelpers,\n  ClassMap,\n  Collection,\n  Configuration,\n  Constructor,\n  Credentials,\n  DefaultObject,\n  Dictionary,\n  EmailPasswordAuthClient,\n  INTERNAL,\n  List,\n  MigrationCallback,\n  ObjectSchema,\n  OrderedCollection,\n  ProgressRealmPromise,\n  RealmEvent,\n  RealmInsertionModel,\n  RealmListenerCallback,\n  RealmListeners,\n  RealmObject,\n  RealmObjectConstructor,\n  RealmSet,\n  Results,\n  SyncSession,\n  TypeAssertionError,\n  Types,\n  UpdateMode,\n  User,\n  assert,\n  binding,\n  extendDebug,\n  fromBindingRealmSchema,\n  fs,\n  normalizeObjectSchema,\n  normalizeRealmSchema,\n  toArrayBuffer,\n  toBindingSchema,\n  toBindingSyncConfig,\n  validateConfiguration,\n  validateObjectSchema,\n  validateRealmSchema,\n} from \"./internal\";\n\nconst debug = extendDebug(\"Realm\");\n\ntype RealmSchemaExtra = Record<string, ObjectSchemaExtra | undefined>;\n\ntype ObjectSchemaExtra = {\n  constructor?: RealmObjectConstructor;\n  defaults: Record<string, unknown>;\n  // objectTypes: Record<string, unknown>;\n};\n\n// Using a set of weak refs to avoid prevention of garbage collection\nconst RETURNED_REALMS = new Set<WeakRef<binding.Realm>>();\nconst NOT_VERSIONED = 18446744073709551615n;\n\nexport type RealmEventName = \"change\" | \"schema\" | \"beforenotify\";\n\n/**\n * Asserts the event passed as string is a valid RealmEvent value.\n * @throws {@link TypeAssertionError} If an unexpected name is passed via {@link name}.\n * @param name The name of the event.\n * @internal\n */\nfunction assertRealmEvent(name: RealmEventName): asserts name is RealmEvent {\n  const values = Object.values(RealmEvent);\n  if (!values.includes(name as RealmEvent)) {\n    throw new TypeAssertionError(\"One of \" + values.join(\", \"), name);\n  }\n}\n\nexport class Realm {\n  public static Object = RealmObject;\n  public static Collection = Collection;\n  public static OrderedCollection = OrderedCollection;\n  public static Results = Results;\n  public static List = List;\n  public static Dictionary = Dictionary;\n  public static Set = RealmSet;\n  public static App = App;\n  public static UpdateMode = UpdateMode;\n  public static BSON = BSON;\n  public static Types = Types;\n  public static User = User;\n  public static Credentials = Credentials;\n  public static Auth = { EmailPasswordAuth: EmailPasswordAuthClient, ApiKeyAuth: ApiKeyAuthClient };\n\n  public static defaultPath = Realm.normalizePath(\"default.realm\");\n\n  /**\n   * Clears the state by closing and deleting any Realm in the default directory and logout all users.\n   * @private Not a part of the public API: It's primarily used from the library's tests.\n   */\n  public static clearTestState(): void {\n    // Close any realms not already closed\n    for (const weakRealm of RETURNED_REALMS) {\n      const realm = weakRealm.deref();\n      if (realm && !realm.isClosed) {\n        realm.close();\n      }\n    }\n    RETURNED_REALMS.clear();\n    binding.RealmCoordinator.clearAllCaches();\n\n    // Delete all Realm files in the default directory\n    const defaultDirectoryPath = fs.getDefaultDirectoryPath();\n    for (const dirent of fs.readDirectory(defaultDirectoryPath)) {\n      const direntPath = fs.joinPaths(defaultDirectoryPath, dirent.name);\n      if (dirent.isDirectory() && dirent.name.endsWith(\".realm.management\")) {\n        fs.removeDirectory(direntPath);\n      } else if (\n        dirent.name.endsWith(\".realm\") ||\n        dirent.name.endsWith(\".realm.note\") ||\n        dirent.name.endsWith(\".realm.lock\") ||\n        dirent.name.endsWith(\".realm.log\")\n      ) {\n        fs.removeFile(direntPath);\n      }\n    }\n\n    binding.App.clearCachedApps();\n  }\n\n  /**\n   * Delete the Realm file for the given configuration.\n   * @param config The configuration for the Realm\n   * @throws {@link Error} If anything in the provided {@link config} is invalid.\n   */\n  public static deleteFile(config: Configuration): void {\n    const path = Realm.determinePath(config);\n    fs.removeFile(path);\n    fs.removeFile(path + \".lock\");\n    fs.removeFile(path + \".note\");\n    fs.removeDirectory(path + \".management\");\n  }\n\n  /**\n   * Checks if the Realm already exists on disk.\n   * @param arg The configuration for the Realm or the path to it.\n   * @throws {@link Error} If anything in the provided {@link config} is invalid.\n   * @returns `true` if the Realm exists on the device, `false` if not.\n   */\n  public static exists(arg: Configuration | string = {}): boolean {\n    const config = typeof arg === \"string\" ? { path: arg } : arg;\n    validateConfiguration(config);\n    const path = Realm.determinePath(config);\n    return fs.exists(path);\n  }\n\n  /**\n   * Open a Realm asynchronously with a promise. If the Realm is synced, it will be fully\n   * synchronized before it is available.\n   * In the case of query-based sync, {@link Configuration.scheme | config.schema} is required. An exception will be\n   * thrown if {@link Configuration.scheme | config.schema} is not defined.\n   * @param arg The configuration for the Realm or the path to it.\n   * @returns A promise that will be resolved with the Realm instance when it's available.\n   * @throws {@link Error} If anything in the provided {@link arg} is invalid.\n   */\n  public static open(arg: Configuration | string = {}): ProgressRealmPromise {\n    const config = typeof arg === \"string\" ? { path: arg } : arg;\n    return new ProgressRealmPromise(config);\n  }\n\n  /**\n   * Get the current schema version of the Realm at the given path.\n   * @param path The path to the file where the\n   *   Realm database is stored.\n   * @param encryptionKey Required only when\n   *   accessing encrypted Realms.\n   * @throws {@link Error} If passing an invalid or non-matching encryption key.\n   * @returns Version of the schema, or `-1` if no Realm exists at {@link path}.\n   */\n  public static schemaVersion(path: string, encryptionKey?: ArrayBuffer | ArrayBufferView): number {\n    const config: Configuration = { path };\n    const absolutePath = Realm.determinePath(config);\n    const schemaVersion = binding.Realm.getSchemaVersion({\n      path: absolutePath,\n      encryptionKey: Realm.determineEncryptionKey(encryptionKey),\n    });\n    if (schemaVersion === NOT_VERSIONED) {\n      return -1;\n    } else {\n      return Number(schemaVersion);\n    }\n  }\n\n  /**\n   * Creates a template object for a Realm model class where all optional fields are undefined\n   * and all required fields have the default value for the given data type, either the value\n   * set by the default property in the schema or the default value for the datatype if the schema\n   * doesn't specify one, i.e. 0, false and \"\".\n   *\n   * @param objectSchema Schema describing the object that should be created.\n   */\n  public static createTemplateObject<T extends Record<string, unknown>>(objectSchema: Realm.ObjectSchema): T {\n    validateObjectSchema(objectSchema);\n    const normalizedSchema = normalizeObjectSchema(objectSchema);\n    const result: Record<string, unknown> = {};\n\n    for (const [key, property] of Object.entries(normalizedSchema.properties)) {\n      // If a default value is explicitly set, always set the property\n      if (typeof property.default !== \"undefined\") {\n        result[key] = property.default;\n        continue;\n      }\n      // if optional is set, it wil take precedence over any `?` set on the type parameter\n      if (property.optional) {\n        continue;\n      }\n\n      // Set the default value for all required primitive types.\n      // Lists are always treated as empty if not specified and references to objects are always optional\n      switch (property.type) {\n        case \"bool\":\n          result[key] = false;\n          break;\n        case \"int\":\n          result[key] = 0;\n          break;\n        case \"float\":\n          result[key] = 0.0;\n          break;\n        case \"double\":\n          result[key] = 0.0;\n          break;\n        case \"string\":\n          result[key] = \"\";\n          break;\n        case \"data\":\n          result[key] = new ArrayBuffer(0);\n          break;\n        case \"date\":\n          result[key] = new Date(0);\n          break;\n      }\n    }\n    return result as T;\n  }\n\n  /**\n   * Copy any Realm files  (i.e. `*.realm`) bundled with the application from the application\n   * directory into the application's documents directory, so that they can be opened and used\n   * by Realm. If the file already exists in the documents directory, it will not be\n   * overwritten, so this can safely be called multiple times.\n   *\n   * This should be called before opening the Realm, in order to move the bundled Realm\n   * files into a place where they can be written to, for example:\n   *\n   * ```\n   * // Given a bundled file, example.realm, this will copy example.realm (and any other .realm files)\n   * // from the app bundle into the app's documents directory. If the file already exists, it will\n   * // not be overwritten, so it is safe to call this every time the app starts.\n   * Realm.copyBundledRealmFiles();\n   *\n   * const realm = await Realm.open({\n   *   // This will open example.realm from the documents directory, with the bundled data in.\n   *   path: \"example.realm\"\n   * });\n   * ```\n   *\n   * This is only implemented for React Native.\n   *\n   * @throws {@link Error} If an I/O error occured or method is not implemented.\n   */\n  public static copyBundledRealmFiles() {\n    fs.copyBundledRealmFiles();\n  }\n\n  private static normalizePath(path: string | undefined): string {\n    if (typeof path === \"undefined\") {\n      return Realm.defaultPath;\n    } else if (path.length === 0) {\n      throw new Error(\"Unexpected empty path\");\n    } else if (fs.isAbsolutePath(path)) {\n      return path;\n    } else {\n      return fs.joinPaths(fs.getDefaultDirectoryPath(), path);\n    }\n  }\n\n  private static determinePath(config: Configuration): string {\n    if (config.path || !config.sync) {\n      return Realm.normalizePath(config.path);\n    } else {\n      // TODO: Determine if it's okay to get the syncManager through the app instead of the user:\n      // return user->m_user->sync_manager()->path_for_realm(*(config.sync_config));\n      const bindingSyncConfig = toBindingSyncConfig(config.sync);\n      return config.sync.user.app.internal.syncManager.pathForRealm(bindingSyncConfig);\n    }\n  }\n\n  private static determineEncryptionKey(encryptionKey: Configuration[\"encryptionKey\"]): ArrayBuffer | undefined {\n    if (typeof encryptionKey === \"undefined\") {\n      return encryptionKey;\n    } else {\n      return toArrayBuffer(encryptionKey, false);\n    }\n  }\n\n  private static extractSchemaExtras(schemas: CanonicalObjectSchema[]): RealmSchemaExtra {\n    return Object.fromEntries(\n      schemas.map((schema) => {\n        const defaults = Object.fromEntries(\n          Object.entries(schema.properties).map(([name, property]) => {\n            return [name, property.default];\n          }),\n        );\n        return [schema.name, { defaults, constructor: schema.constructor }];\n      }),\n    );\n  }\n\n  /** @internal */\n  public static transformConfig(config: Configuration): {\n    schemaExtras: RealmSchemaExtra;\n    bindingConfig: binding.RealmConfig_Relaxed;\n  } {\n    const normalizedSchema = config.schema && normalizeRealmSchema(config.schema);\n    const schemaExtras = Realm.extractSchemaExtras(normalizedSchema || []);\n    const path = Realm.determinePath(config);\n    const { fifoFilesFallbackPath, shouldCompact, inMemory } = config;\n    const bindingSchema = normalizedSchema && toBindingSchema(normalizedSchema);\n    return {\n      schemaExtras,\n      bindingConfig: {\n        path,\n        cache: true,\n        fifoFilesFallbackPath,\n        schema: bindingSchema,\n        inMemory: inMemory === true,\n        schemaMode: Realm.determineSchemaMode(config),\n        schemaVersion: config.schema\n          ? typeof config.schemaVersion === \"number\"\n            ? BigInt(config.schemaVersion)\n            : 0n\n          : undefined,\n        migrationFunction: config.onMigration ? Realm.wrapMigration(schemaExtras, config.onMigration) : undefined,\n        shouldCompactOnLaunchFunction: shouldCompact\n          ? (totalBytes, usedBytes) => {\n              return shouldCompact(Number(totalBytes), Number(usedBytes));\n            }\n          : undefined,\n        disableFormatUpgrade: config.disableFormatUpgrade,\n        encryptionKey: Realm.determineEncryptionKey(config.encryptionKey),\n        syncConfig: config.sync ? toBindingSyncConfig(config.sync) : undefined,\n      },\n    };\n  }\n\n  private static determineSchemaMode(config: Configuration): binding.SchemaMode | undefined {\n    const { readOnly, deleteRealmIfMigrationNeeded, onMigration, sync } = config;\n    assert(\n      !readOnly || !deleteRealmIfMigrationNeeded,\n      \"Cannot set 'deleteRealmIfMigrationNeeded' when 'readOnly' is set.\",\n    );\n    assert(\n      !onMigration || !deleteRealmIfMigrationNeeded,\n      \"Cannot set 'deleteRealmIfMigrationNeeded' when 'onMigration' is set.\",\n    );\n    if (readOnly) {\n      return binding.SchemaMode.Immutable;\n    } else if (deleteRealmIfMigrationNeeded) {\n      return binding.SchemaMode.SoftResetFile;\n    } else if (sync) {\n      return binding.SchemaMode.AdditiveExplicit;\n    } else {\n      return undefined;\n    }\n  }\n\n  private static wrapMigration(\n    schemaExtras: RealmSchemaExtra,\n    onMigration: MigrationCallback,\n  ): binding.RealmConfig_Relaxed[\"migrationFunction\"] {\n    return (oldRealmInternal: binding.Realm, newRealmInternal: binding.Realm) => {\n      try {\n        const oldRealm = new Realm(oldRealmInternal, schemaExtras);\n        const newRealm = new Realm(newRealmInternal, schemaExtras);\n        onMigration(oldRealm, newRealm);\n      } finally {\n        oldRealmInternal.close();\n        oldRealmInternal.$resetSharedPtr();\n        newRealmInternal.$resetSharedPtr();\n      }\n    };\n  }\n\n  /**\n   * The Realms's representation in the binding.\n   * @internal\n   */\n  public readonly internal: binding.Realm;\n\n  /**\n   * The sync session if this is a synced Realm\n   */\n  public readonly syncSession: SyncSession | null;\n\n  private schemaExtras: RealmSchemaExtra = {};\n  private classes: ClassMap;\n  private changeListeners = new RealmListeners(this, RealmEvent.Change);\n  private beforeNotifyListeners = new RealmListeners(this, RealmEvent.BeforeNotify);\n  private schemaListeners = new RealmListeners(this, RealmEvent.Schema);\n\n  constructor();\n  /**\n   * Create a new {@link Realm} instance at the provided {@link path}.\n   * @param path Required when first creating the Realm.\n   * @throws {@link Error} If the Realm cannot be opened at the provided {@link path}.\n   * @throws {@link Error} When an incompatible synced Realm is opened.\n   */\n  constructor(path: string);\n  /**\n   * Create a new {@link Realm} instance using the provided {@link config}. If a Realm does not yet exist\n   * at {@link Configuration.path | config.path} (or {@link defaultPath} if not provided), then this constructor\n   * will create it with the provided {@link Configuration.schema | config.schema} (which is _required_ in this case).\n   * Otherwise, the instance will access the existing Realm from the file at that path.\n   * In this case, {@link Configuration.schema | config.schema} is _optional_ or not have changed, unless\n   * {@link Configuration.schemaVersion | config.schemaVersion} is incremented, in which case the Realm will be automatically\n   * migrated to use the new schema.\n   * In the case of query-based sync, {@link Configuration.schema | config.schema} is required. An exception will be\n   * thrown if {@link Configuration.schema | config.schema} is not defined.\n   * @param config Required when first creating the Realm.\n   * @throws {@link Error} If anything in the provided {@link config} is invalid.\n   * @throws {@link Error} When an incompatible synced Realm is opened.\n   */\n  constructor(config: Configuration);\n  /** @internal */\n  constructor(config: Configuration, internal: binding.Realm);\n  /** @internal */\n  constructor(internal: binding.Realm, schemaExtras?: RealmSchemaExtra);\n  constructor(arg: Configuration | binding.Realm | string = {}, secondArg?: object) {\n    if (arg instanceof binding.Realm) {\n      this.schemaExtras = (secondArg ?? {}) as RealmSchemaExtra;\n      this.internal = arg;\n    } else {\n      const config = typeof arg === \"string\" ? { path: arg } : arg;\n      validateConfiguration(config);\n      const { bindingConfig, schemaExtras } = Realm.transformConfig(config);\n      debug(\"open\", bindingConfig);\n      this.schemaExtras = schemaExtras;\n      assert(!secondArg || secondArg instanceof binding.Realm, \"The realm constructor only takes a single argument\");\n      this.internal = secondArg ?? binding.Realm.getSharedRealm(bindingConfig);\n\n      binding.Helpers.setBindingContext(this.internal, {\n        didChange: (r) => {\n          r.verifyOpen();\n          this.changeListeners.callback();\n        },\n        schemaDidChange: (r) => {\n          r.verifyOpen();\n          this.schemaListeners.callback();\n        },\n        beforeNotify: (r) => {\n          r.verifyOpen();\n          this.beforeNotifyListeners.callback();\n        },\n      });\n      RETURNED_REALMS.add(new WeakRef(this.internal));\n    }\n\n    Object.defineProperties(this, {\n      classes: {\n        enumerable: false,\n        configurable: false,\n        writable: true,\n      },\n      internal: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n    });\n\n    this.classes = new ClassMap(this, this.internal.schema, this.schema);\n\n    const syncSession = this.internal.syncSession;\n    this.syncSession = syncSession ? new SyncSession(syncSession) : null;\n  }\n\n  /**\n   * Indicates if this Realm contains any objects.\n   * @readonly\n   * @since 1.10.0\n   */\n  get isEmpty(): boolean {\n    return binding.Helpers.isEmptyRealm(this.internal);\n  }\n\n  /**\n   * The path to the file where this Realm is stored.\n   * @readonly\n   * @since 0.12.0\n   */\n  get path(): string {\n    return this.internal.config.path;\n  }\n\n  /**\n   * Indicates if this Realm was opened as read-only.\n   * @readonly\n   * @since 0.12.0\n   */\n  get isReadOnly(): boolean {\n    return this.internal.config.schemaMode === binding.SchemaMode.Immutable;\n  }\n\n  /**\n   * Indicates if this Realm was opened in-memory.\n   * @readonly\n   */\n  get isInMemory(): boolean {\n    return this.internal.config.inMemory;\n  }\n\n  /**\n   * A normalized representation of the schema provided in the {@link Configuration} when this Realm was constructed.\n   * @readonly\n   * @since 0.12.0\n   */\n  get schema(): CanonicalObjectSchema[] {\n    const schemas = fromBindingRealmSchema(this.internal.schema);\n    // Stitch in the constructors and defaults stored in this.schemaExtras\n    for (const objectSchema of schemas) {\n      const extras = this.schemaExtras[objectSchema.name];\n      if (extras) {\n        objectSchema.constructor = extras.constructor;\n      }\n      for (const property of Object.values(objectSchema.properties)) {\n        property.default = extras ? extras.defaults[property.name] : undefined;\n      }\n    }\n    return schemas;\n  }\n\n  /**\n   * The current schema version of the Realm.\n   * @readonly\n   * @since 0.12.0\n   */\n  get schemaVersion(): number {\n    return Number(this.internal.schemaVersion);\n  }\n\n  /**\n   * Indicates if this Realm is in a write transaction.\n   * @readonly\n   * @since 1.10.3\n   */\n  get isInTransaction(): boolean {\n    // TODO: Consider keeping a local state in JS for this\n    return this.internal.isInTransaction;\n  }\n\n  /**\n   * Indicates if this Realm has been closed.\n   * @readonly\n   * @since 2.1.0\n   */\n  get isClosed(): boolean {\n    // TODO: Consider keeping a local state in JS for this\n    return this.internal.isClosed;\n  }\n\n  /**\n   * The latest set of flexible sync subscriptions.\n   * @throws {@link Error} If flexible sync is not enabled for this app\n   */\n  get subscriptions(): any {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  /**\n   * Closes this Realm so it may be re-opened with a newer schema version.\n   * All objects and collections from this Realm are no longer valid after calling this method.\n   * The method is idempotent.\n   */\n  close(): void {\n    this.internal.close();\n    this.syncSession?.resetInternal();\n  }\n\n  // TODO: Support embedded objects and asymmetric sync\n  // TODO: Rollback by deleting the object if any property assignment fails (fixing #2638)\n  /**\n   * Create a new Realm object of the given type and with the specified properties. For object schemas annotated\n   * as asymmetric, no object is returned. The API for asymmetric object schema is subject to changes in the future.\n   * @param type The type of Realm object to create.\n   * @param values Property values for all required properties without a\n   *   default value.\n   * @param mode Optional update mode. It can be one of the following values\n   *     - UpdateMode.Never: Objects are only created. If an existing object exists, an exception is thrown. This is the\n   *       default value.\n   *     - UpdateMode.All: If an existing object is found, all properties provided will be updated, any other properties will\n   *       remain unchanged.\n   *     - UpdateMode.Modified: If an existing object exists, only properties where the value has actually changed will be\n   *       updated. This improves notifications and server side performance but also have implications for how changes\n   *       across devices are merged. For most use cases, the behaviour will match the intuitive behaviour of how\n   *       changes should be merged, but if updating an entire object is considered an atomic operation, this mode\n   *       should not be used.\n   */\n  create<T = DefaultObject>(type: string, values: RealmInsertionModel<T>, mode?: UpdateMode.Never): RealmObject<T> & T;\n  create<T = DefaultObject>(\n    type: string,\n    values: Partial<T> | Partial<RealmInsertionModel<T>>,\n    mode: UpdateMode.All | UpdateMode.Modified | boolean,\n  ): RealmObject<T> & T;\n  create<T extends RealmObject>(type: Constructor<T>, values: RealmInsertionModel<T>, mode?: UpdateMode.Never): T;\n  create<T extends RealmObject>(\n    type: Constructor<T>,\n    values: Partial<T> | Partial<RealmInsertionModel<T>>,\n    mode: UpdateMode.All | UpdateMode.Modified | boolean,\n  ): T;\n  create<T extends RealmObject>(\n    type: string | Constructor<T>,\n    values: DefaultObject,\n    mode: UpdateMode | boolean = UpdateMode.Never,\n  ) {\n    // Supporting a boolean overload for mode\n    if (mode === true) {\n      mode = UpdateMode.All;\n    } else if (mode === false) {\n      mode = UpdateMode.Never;\n    }\n    // Implements https://github.com/realm/realm-js/blob/v11/src/js_realm.hpp#L1260-L1321\n    if (values instanceof RealmObject && !values[INTERNAL]) {\n      throw new Error(\"Cannot create an object from a detached Realm.Object instance\");\n    }\n    if (!Object.values(UpdateMode).includes(mode)) {\n      throw new Error(\"Unsupported 'updateMode'. Only 'never', 'modified' or 'all' is supported.\");\n    }\n    this.internal.verifyOpen();\n    const helpers = this.classes.getHelpers(type);\n    return RealmObject.create(this, values, mode, { helpers });\n  }\n\n  /**\n   * Deletes the provided Realm object, or each one inside the provided collection.\n   */\n  delete(subject: RealmObject | RealmObject[] | List | Results): void {\n    assert.inTransaction(this, \"Can only delete objects within a transaction.\");\n    assert.object(subject, \"subject\");\n    if (subject instanceof RealmObject) {\n      const { objectSchema } = this.classes.getHelpers(subject);\n      const obj = subject[INTERNAL];\n      assert.isValid(\n        obj,\n        \"Object is invalid. Either it has been previously deleted or the Realm it belongs to has been closed.\",\n      );\n      const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n      table.removeObject(obj.key);\n    } else if (subject instanceof List) {\n      subject.internal.deleteAll();\n    } else if (subject instanceof Results) {\n      subject.internal.clear();\n    } else if (Array.isArray(subject) || Symbol.iterator in subject) {\n      for (const object of subject) {\n        assert.instanceOf(object, RealmObject);\n        const { objectSchema } = this.classes.getHelpers(object);\n        const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n        table.removeObject(object[INTERNAL].key);\n      }\n    } else {\n      throw new Error(\"Can only delete objects, lists and results.\");\n    }\n  }\n\n  /**\n   * Deletes a Realm model, including all of its objects.\n   * If called outside a migration function, {@link schema} and {@link schemaVersion} are updated.\n   * @param name The model name\n   */\n  deleteModel(name: string): void {\n    assert.inTransaction(this, \"Can only delete objects within a transaction.\");\n    binding.Helpers.deleteDataForObject(this.internal, name);\n    if (!this.internal.isInMigration) {\n      const newSchema = this.internal.schema.filter((objectSchema) => objectSchema.name !== name);\n      this.internal.updateSchema(newSchema, this.internal.schemaVersion + 1n, null, null, true);\n    }\n  }\n\n  /**\n   * **WARNING:** This will delete **all** objects in the Realm!\n   */\n  deleteAll(): void {\n    assert.inTransaction(this, \"Can only delete objects within a transaction.\");\n    for (const objectSchema of this.internal.schema) {\n      const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n      table.clear();\n    }\n  }\n\n  /**\n   * Searches for a Realm object by its primary key.\n   * @param type The type of Realm object to search for.\n   * @param primaryKey The primary key value of the object to search for.\n   * @throws {@link Error} If type passed into this method is invalid or if the object type did\n   * not have a {@link primaryKey} specified in the schema.\n   * @returns A Realm.Object or undefined if no object is found.\n   * @since 0.14.0\n   */\n  objectForPrimaryKey<T = DefaultObject>(type: string, primaryKey: T[keyof T]): (RealmObject<T> & T) | null;\n  objectForPrimaryKey<T extends RealmObject>(type: Constructor<T>, primaryKey: T[keyof T]): T | null;\n  objectForPrimaryKey<T extends RealmObject>(type: string | Constructor<T>, primaryKey: unknown): T | null {\n    // Implements https://github.com/realm/realm-js/blob/v11/src/js_realm.hpp#L1240-L1258\n    const { objectSchema, properties, wrapObject } = this.classes.getHelpers(type);\n    if (!objectSchema.primaryKey) {\n      throw new Error(`Expected a primary key on '${objectSchema.name}'`);\n    }\n    const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n    const value = properties.get(objectSchema.primaryKey).toBinding(primaryKey, undefined);\n    try {\n      const objKey = table.findPrimaryKey(value);\n      // This relies on the JS represenation of an ObjKey being a bigint\n      if (binding.isEmptyObjKey(objKey)) {\n        return null;\n      } else {\n        const obj = table.getObject(objKey);\n        return wrapObject(obj) as T;\n      }\n    } catch (err) {\n      // TODO: Match on something else than the error message, when exposed by the binding\n      if (err instanceof Error && err.message.startsWith(\"No object with key\")) {\n        throw new Error(`No '${objectSchema.name}' with key '${primaryKey}'`);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Returns all objects of the given {@link type} in the Realm.\n   * @param type The type of Realm objects to retrieve.\n   * @throws {@link Error} If type passed into this method is invalid or if the type is marked embedded or asymmetric.\n   * @returns Realm.Results that will live-update as objects are created and destroyed.\n   */\n  /**\n   * @internal\n   */\n  _objectForObjectKey<T = DefaultObject>(type: string, objectKey: string): (RealmObject<T> & T) | undefined;\n  _objectForObjectKey<T extends RealmObject>(type: Constructor<T>, objectKey: string): T | undefined;\n  _objectForObjectKey<T extends RealmObject>(type: string | Constructor<T>, objectKey: string): T | undefined {\n    const { objectSchema, wrapObject } = this.classes.getHelpers(type);\n    const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n    try {\n      const objKey = binding.stringToObjKey(objectKey);\n      const obj = table.tryGetObject(objKey);\n      const result = wrapObject(obj) as T;\n      return result === null ? undefined : result;\n    } catch (err) {\n      if (err instanceof binding.InvalidObjKey) {\n        return undefined;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  objects<T>(type: string): Results<RealmObject & T>;\n  objects<T extends RealmObject = RealmObject>(type: Constructor<T>): Results<T>;\n  objects<T extends RealmObject = RealmObject>(type: string | Constructor<T>): Results<T> {\n    const { objectSchema, wrapObject } = this.classes.getHelpers(type);\n    if (objectSchema.tableType === binding.TableType.Embedded) {\n      throw new Error(\"You cannot query an embedded object.\");\n    } else if (objectSchema.tableType === binding.TableType.TopLevelAsymmetric) {\n      throw new Error(\"You cannot query an asymmetric class.\");\n    }\n\n    const table = binding.Helpers.getTable(this.internal, objectSchema.tableKey);\n    const results = binding.Results.fromTable(this.internal, table);\n    return new Results<T>(this, results, {\n      get(results: binding.Results, index: number) {\n        return results.getObj(index);\n      },\n      fromBinding: wrapObject,\n      toBinding(value: unknown) {\n        assert.instanceOf(value, RealmObject);\n        return value[INTERNAL];\n      },\n    });\n  }\n\n  /**\n   * Add a listener {@link callback} for the specified {@link eventName}.\n   * @param eventName The name of event that should cause the callback to be called.\n   * @param callback Function to be called when a change event occurs.\n   *   Each callback will only be called once per event, regardless of the number of times\n   *   it was added.\n   * @throws {@link Error} If an invalid event {@link eventName} is supplied, if Realm is closed or if {@link callback} is not a function.\n   */\n  addListener(eventName: RealmEventName, callback: RealmListenerCallback): void {\n    assert.open(this);\n    assert.function(callback);\n    if (eventName === \"change\") {\n      this.changeListeners.add(callback);\n    } else if (eventName === \"schema\") {\n      this.schemaListeners.add(callback);\n    } else if (eventName === \"beforenotify\") {\n      this.beforeNotifyListeners.add(callback);\n    } else {\n      throw new Error(`Unknown event name '${eventName}': only 'change', 'schema' and 'beforenotify' are supported.`);\n    }\n  }\n\n  /**\n   * Remove the listener {@link callback} for the specfied event {@link eventName}.\n   * @param eventName The event name.\n   * @param callback Function that was previously added as a listener for this event through the {@link addListener} method.\n   * @throws {@link Error} If an invalid event {@link eventName} is supplied, if Realm is closed or if {@link callback} is not a function.\n   */\n  removeListener(eventName: RealmEventName, callback: RealmListenerCallback): void {\n    assert.open(this);\n    assert.function(callback);\n    assertRealmEvent(eventName);\n    if (eventName === RealmEvent.Change) {\n      this.changeListeners.remove(callback);\n    } else if (eventName === RealmEvent.Schema) {\n      this.schemaListeners.remove(callback);\n    } else if (eventName === RealmEvent.BeforeNotify) {\n      this.beforeNotifyListeners.remove(callback);\n    } else {\n      throw assert.never(eventName, \"eventName\");\n    }\n  }\n\n  /**\n   * Remove all event listeners (restricted to the event {@link eventName}, if provided).\n   * @param eventName The name of the event whose listeners should be removed.\n   * @throws {@link Error} When invalid event {@link eventName} is supplied\n   */\n  removeAllListeners(eventName?: RealmEventName): void {\n    assert.open(this);\n    if (typeof eventName === \"undefined\") {\n      this.changeListeners.removeAll();\n      this.schemaListeners.removeAll();\n      this.beforeNotifyListeners.removeAll();\n    } else {\n      assert.string(eventName, \"eventName\");\n      assertRealmEvent(eventName);\n      if (eventName === RealmEvent.Change) {\n        this.changeListeners.removeAll();\n      } else if (eventName === RealmEvent.Schema) {\n        this.schemaListeners.removeAll();\n      } else if (eventName === RealmEvent.BeforeNotify) {\n        this.beforeNotifyListeners.removeAll();\n      } else {\n        throw assert.never(eventName, \"eventName\");\n      }\n    }\n  }\n\n  /**\n   * Synchronously call the provided {@link callback} inside a write transaction. If an exception happens inside a transaction,\n   * you’ll lose the changes in that transaction, but the Realm itself won’t be affected (or corrupted).\n   * More precisely, {@link beginTransaction} and {@link commitTransaction} will be called\n   * automatically. If any exception is thrown during the transaction {@link cancelTransaction} will\n   * be called instead of {@link commitTransaction} and the exception will be re-thrown to the caller of {@link write}.\n   *\n   * Nested transactions (calling {@link write} within {@link write}) is not possible.\n   * @returns Returned value from the callback.\n   */\n  write<T>(callback: () => T): T {\n    let result = undefined;\n    this.internal.beginTransaction();\n    try {\n      result = callback();\n    } catch (err) {\n      this.internal.cancelTransaction();\n      throw err;\n    }\n    this.internal.commitTransaction();\n    return result;\n  }\n\n  /**\n   * Initiate a write transaction.\n   *\n   * When doing a transaction, it is highly recommended to do error handling.\n   * If you don't handle errors, your data might become inconsistent. Error handling\n   * will often involve canceling the transaction.\n   *\n   * @throws {@link Error} If already in write transaction\n   * @see {@link cancelTransaction}\n   * @see {@link commitTransaction}\n   * @example\n   * realm.beginTransaction();\n   * try {\n   *   realm.create('Person', { name: 'Arthur Dent',  origin: 'Earth' });\n   *   realm.create('Person', { name: 'Ford Prefect', origin: 'Betelgeuse Five' });\n   *   realm.commitTransaction();\n   * } catch (e) {\n   *   realm.cancelTransaction();\n   *   throw e;\n   * }\n   */\n  beginTransaction(): void {\n    this.internal.beginTransaction();\n  }\n\n  /**\n   * Commit a write transaction.\n   *\n   * @see {@link beginTransaction}\n   */\n  commitTransaction(): void {\n    this.internal.commitTransaction();\n  }\n\n  /**\n   * Cancel a write transaction.\n   *\n   * @see {@link beginTransaction}\n   */\n  cancelTransaction(): void {\n    this.internal.cancelTransaction();\n  }\n\n  /**\n   * Replaces all string columns in this Realm with a string enumeration column and compacts the\n   * database file.\n   *\n   * Cannot be called from a write transaction.\n   *\n   * Compaction will not occur if other {@link Realm} instances exist.\n   *\n   * While compaction is in progress, attempts by other threads or processes to open the database will\n   * wait.\n   *\n   * Be warned that resource requirements for compaction is proportional to the amount of live data in\n   * the database. Compaction works by writing the database contents to a temporary database file and\n   * then replacing the database with the temporary one.\n   * @returns `true` if compaction succeeds, `false` if not.\n   */\n  compact(): boolean {\n    assert.outTransaction(this, \"Cannot compact a Realm within a transaction.\");\n    return this.internal.compact();\n  }\n\n  /**\n   * Writes a compacted copy of the Realm with the given configuration.\n   *\n   * The destination file cannot already exist.\n   * All conversions between synced and non-synced Realms are supported, and will be\n   * performed according to the {@link config} parameter, which describes the desired output.\n   *\n   * Note that if this method is called from within a write transaction, the current data is written,\n   * not the data from the point when the previous write transaction was committed.\n   * @param config Realm configuration that describes the output realm.\n   */\n  writeCopyTo(config: Configuration) {\n    assert.outTransaction(this, \"Can only convert Realms outside a transaction.\");\n    validateConfiguration(config);\n    const { bindingConfig } = Realm.transformConfig(config);\n    this.internal.convert(bindingConfig);\n  }\n\n  /**\n   * Update the schema of the Realm.\n   *\n   * @param schema The schema which the Realm should be updated to use.\n   * @internal Consider passing a {@link schema} when constructing the {@link Realm} instead.\n   */\n  _updateSchema(schema: Realm.ObjectSchema[]): void {\n    validateRealmSchema(schema);\n    const normalizedSchema = normalizeRealmSchema(schema);\n    const bindingSchema = toBindingSchema(normalizedSchema);\n    if (!this.isInTransaction) {\n      throw new Error(\"Can only create object schema within a transaction.\");\n    }\n    this.internal.updateSchema(bindingSchema, this.internal.schemaVersion + 1n, null, null, true);\n    this.classes = new ClassMap(this, this.internal.schema, this.schema);\n  }\n\n  /**\n   * @internal\n   */\n  public getClassHelpers<T>(\n    arg: string | binding.TableKey | RealmObject<T> | Constructor<RealmObject<T>>,\n  ): ClassHelpers {\n    return this.classes.getHelpers<T>(arg);\n  }\n}\n\n// Declare the Realm namespace for backwards compatibility\n\n// We need this alias because of https://github.com/Swatinem/rollup-plugin-dts/issues/223\ntype CollectionType<T> = Collection<T>;\ntype OrderedCollectionType<T> = OrderedCollection<T>;\ntype ResultsType<T> = Results<T>;\ntype ListType<T> = List<T>;\ntype DictionaryType<T> = Dictionary<T>;\ntype SetType<T> = RealmSet<T>;\ntype AppType = App;\ntype UpdateModeType = UpdateMode;\ntype ObjectSchemaType = ObjectSchema;\ntype BSONType = typeof BSON;\ntype TypesType = typeof Types;\ntype UserType = typeof User;\ntype CredentialsType = typeof Credentials;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Realm {\n  export type Object<T = DefaultObject> = RealmObject<T>;\n  export type Collection<T = unknown> = CollectionType<T>;\n  export type OrderedCollection<T = unknown> = OrderedCollectionType<T>;\n  export type Results<T = unknown> = ResultsType<T>;\n  export type List<T = unknown> = ListType<T>;\n  export type Dictionary<T = unknown> = DictionaryType<T>;\n  export type Set<T = unknown> = SetType<T>;\n  export type App = AppType;\n  export type UpdateMode = UpdateModeType;\n  export type ObjectSchema = ObjectSchemaType;\n  export type Mixed = unknown;\n  export type BSON = BSONType;\n  export type Types = TypesType;\n  export type User = UserType;\n  export type Credentials = CredentialsType;\n}\n"]}