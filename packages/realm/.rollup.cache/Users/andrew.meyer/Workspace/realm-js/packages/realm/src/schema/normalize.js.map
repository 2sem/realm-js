{"version":3,"file":"normalize.js","sourceRoot":"","sources":["normalize.ts"],"names":[],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2022 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nimport {\n  CanonicalObjectSchema,\n  CanonicalObjectSchemaProperty,\n  ObjectSchema,\n  ObjectSchemaProperty,\n  PropertyTypeName,\n  RealmObject,\n  RealmObjectConstructor,\n  TYPE_MAPPINGS,\n  assert,\n  flags,\n} from \"../internal\";\n\nexport const PRIMITIVE_TYPES = new Set<PropertyTypeName>([\n  \"bool\",\n  \"int\",\n  \"float\",\n  \"double\",\n  \"decimal128\",\n  \"objectId\",\n  \"string\",\n  \"data\",\n  \"date\",\n  \"mixed\",\n  \"uuid\",\n]);\n\nfunction isPrimitive(type: string | undefined) {\n  return PRIMITIVE_TYPES.has(type as PropertyTypeName);\n}\n\nfunction validateCanonicalPropertySchema(\n  objectSchemaName: string,\n  { name, type, objectType, optional }: CanonicalObjectSchemaProperty,\n) {\n  if (type === \"list\" && objectType === \"list\") {\n    throw new Error(`List property '${objectSchemaName}#${name}' cannot have list elements`);\n  }\n  if (type === \"list\" && !isPrimitive(objectType) && optional) {\n    throw new Error(`List property '${objectSchemaName}#${name}' of '${objectType}' elements, cannot be optional`);\n  }\n  if (objectType === \"\") {\n    throw new Error(`Property '${objectSchemaName}#${name}' cannot have an empty object type`);\n  }\n}\n\nexport const COLLECTION_TYPES: PropertyTypeName[] = [\"set\", \"dictionary\", \"list\"];\n\nfunction removeUndefinedValues<T extends Record<string, unknown>>(obj: T): T {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => typeof v !== \"undefined\")) as T;\n}\n\nexport function normalizeRealmSchema(\n  schema: Readonly<(RealmObjectConstructor | ObjectSchema)[]>,\n): CanonicalObjectSchema[] {\n  return schema.map(normalizeObjectSchema);\n}\n\nexport function normalizeObjectSchema(arg: RealmObjectConstructor | ObjectSchema): CanonicalObjectSchema {\n  if (typeof arg === \"function\") {\n    assert.extends(arg, RealmObject);\n    assert.object(arg.schema, \"schema static\");\n    const schema = normalizeObjectSchema(arg.schema as ObjectSchema);\n    schema.constructor = arg;\n    return schema;\n  } else {\n    // TODO: Determine if we still want to support this\n    if (Array.isArray(arg.properties)) {\n      if (flags.ALLOW_VALUES_ARRAYS) {\n        return normalizeObjectSchema({\n          ...arg,\n          properties: Object.fromEntries(arg.properties.map(({ name, ...rest }) => [name, rest])),\n        });\n      } else {\n        throw new Error(\"Array of properties are no longer supported\");\n      }\n    }\n    return {\n      constructor: undefined,\n      name: arg.name,\n      primaryKey: arg.primaryKey,\n      asymmetric: arg.asymmetric || false,\n      embedded: arg.embedded || false,\n      properties: Object.fromEntries(\n        Object.entries(arg.properties).map(([name, property]) => {\n          const canonicalPropertySchema = normalizePropertySchema(name, property);\n          // A primary key is always indexed\n          if (name === arg.primaryKey) {\n            canonicalPropertySchema.indexed = true;\n          }\n          validateCanonicalPropertySchema(arg.name, canonicalPropertySchema);\n          return [name, canonicalPropertySchema];\n        }),\n      ),\n    };\n  }\n}\n\n// TODO: Extend to handle all short hands\nexport function normalizePropertySchema(\n  name: string,\n  schema: string | ObjectSchemaProperty,\n): CanonicalObjectSchemaProperty {\n  if (typeof schema === \"string\") {\n    return normalizePropertySchema(name, normalizePropertyType(schema));\n  } else {\n    const { type, ...rest } = schema;\n    const propertySchemaFromType = normalizePropertyType(type, typeof rest.objectType !== \"string\");\n    // Type casting, since it is expected that `normalizePropertyType` moves an object linked type into `objectType`\n    const mergedSchema = {\n      ...removeUndefinedValues(propertySchemaFromType),\n      ...removeUndefinedValues(rest as Omit<ObjectSchemaProperty, \"name\">),\n    } as ObjectSchemaProperty & { type: PropertyTypeName };\n    if (mergedSchema.type === \"mixed\" || mergedSchema.objectType === \"mixed\") {\n      assert(mergedSchema.optional !== false, \"Mixed values should be declared as optional\");\n    }\n    const result: CanonicalObjectSchemaProperty = {\n      indexed: false,\n      optional: false,\n      mapTo: name,\n      ...mergedSchema,\n      name,\n    };\n    return result;\n  }\n}\n\nexport function normalizePropertyType(type: string, allowObjectType = true): ObjectSchemaProperty {\n  if (type.endsWith(\"[]\")) {\n    assert(allowObjectType, \"Expected no 'objectType' in property schema, when using '[]' shorthand\");\n    const item = normalizePropertyType(type.substring(0, type.length - 2));\n    assert(item.type === \"object\" || !item.objectType, `Unexpected nested object type ${item.objectType}`);\n    return {\n      type: \"list\",\n      objectType: item.type === \"object\" ? item.objectType : item.type,\n      optional: item.type === \"object\" ? false : !!item.optional,\n    };\n  } else if (type.endsWith(\"<>\")) {\n    assert(allowObjectType, \"Expected no 'objectType' in property schema, when using '<>' shorthand\");\n    const itemType = type.substring(0, type.length - 2);\n    // Item type defaults to mixed\n    const item: ObjectSchemaProperty = itemType ? normalizePropertyType(itemType) : { type: \"mixed\" };\n    return {\n      type: \"set\",\n      objectType: item.type === \"object\" ? item.objectType : item.type,\n      optional: item.type === \"object\" ? true : !!item.optional,\n    };\n  } else if (type.endsWith(\"{}\")) {\n    assert(allowObjectType, \"Expected no 'objectType' in property schema, when using '{}' shorthand\");\n    const itemType = type.substring(0, type.length - 2);\n    // Item type defaults to mixed\n    const item: ObjectSchemaProperty = itemType ? normalizePropertyType(itemType) : { type: \"mixed\", optional: true };\n    return {\n      type: \"dictionary\",\n      objectType: item.type === \"object\" ? item.objectType : item.type,\n      optional: item.type === \"object\" ? true : !!item.optional,\n    };\n  } else if (type.endsWith(\"?\")) {\n    return {\n      optional: true,\n      type: type.substring(0, type.length - 1),\n    };\n  } else if (type in TYPE_MAPPINGS) {\n    if (type === \"dictionary\") {\n      return { type, objectType: \"mixed\", optional: true };\n    } else if (type === \"set\") {\n      return { type, objectType: \"mixed\", optional: true };\n    } else if (type === \"mixed\") {\n      return {type, optional: true};\n    } else {\n      // This type is directly mappable, so it can't be the name a user defined object schema.\n      return { type };\n    }\n  } else {\n    return { type: \"object\", objectType: type, optional: true };\n  }\n}\n\nexport function extractGeneric(type: string): { typeBase: string; typeArgument?: string } {\n  const bracketStart = type.indexOf(\"<\");\n  const bracketEnd = type.indexOf(\">\", bracketStart);\n  if (bracketStart === -1) {\n    return { typeBase: type };\n  } else {\n    return { typeBase: type.substring(0, bracketStart), typeArgument: type.substring(bracketStart + 1, bracketEnd) };\n  }\n}\n"]}